{
  "phase": 4,
  "description": "Joint metrics for dual-task model evaluation (pointer regression + type classification)",
  "overview": "Evaluates model performance where BOTH pointer localization AND type classification must be correct for a prediction to count as successful",

  "joint_metrics": {
    "joint_accuracy": {
      "description": "Fraction of samples where BOTH pointer and type are correct",
      "formula": "(pointer_hit AND type_correct) / total_samples",
      "range": [0.0, 1.0],
      "target": ">0.50"
    },
    "joint_f1": {
      "description": "F1 score treating (type, pointer_hit) combinations as classes",
      "classes": {
        "0": "type=0, pointer_miss",
        "1": "type=0, pointer_hit",
        "2": "type=1, pointer_miss",
        "3": "type=1, pointer_hit"
      },
      "range": [0.0, 1.0],
      "target": ">0.60"
    },
    "task_contribution": {
      "description": "Breakdown of which tasks contribute to errors",
      "categories": {
        "both_correct": "Both pointer and type correct",
        "pointer_only_correct": "Pointer correct, type wrong",
        "type_only_correct": "Type correct, pointer wrong",
        "both_wrong": "Both pointer and type wrong"
      }
    }
  },

  "usage": {
    "model_selection": {
      "primary_metric": "joint_f1 or joint_accuracy",
      "minimum_thresholds": {
        "pointer_hit_rate": 0.4,
        "type_accuracy": 0.5
      },
      "rationale": "Use joint metric to rank models, but enforce minimum thresholds to prevent extreme task imbalance"
    },
    "error_analysis": {
      "use_case": "Diagnose which task needs improvement",
      "example_1": "If pointer_only_correct is high: Type classifier needs work",
      "example_2": "If type_only_correct is high: Pointer regression needs work",
      "example_3": "If both_wrong is high: Fundamental model capacity issue"
    },
    "hyperparameter_tuning": {
      "use_case": "Adjust loss_beta to balance tasks",
      "if_pointer_only_high": "Decrease loss_beta (more weight on type)",
      "if_type_only_high": "Increase loss_beta (more weight on pointer)",
      "optimal_balance": "both_correct should dominate other categories"
    }
  },

  "expected_values": {
    "baseline_untrained": {
      "joint_accuracy": 0.05,
      "joint_f1": 0.10,
      "pointer_hit_rate": 0.10,
      "type_accuracy": 0.50,
      "note": "Random type classification, untrained pointer regression"
    },
    "good_performance": {
      "joint_accuracy": 0.50,
      "joint_f1": 0.60,
      "pointer_hit_rate": 0.65,
      "type_accuracy": 0.70,
      "note": "Both tasks performing reasonably well"
    },
    "excellent_performance": {
      "joint_accuracy": 0.70,
      "joint_f1": 0.75,
      "pointer_hit_rate": 0.80,
      "type_accuracy": 0.85,
      "note": "Strong performance on both tasks"
    }
  },

  "interpretation": {
    "joint_accuracy_vs_components": {
      "principle": "Joint accuracy is ALWAYS <= min(pointer_hit_rate, type_accuracy)",
      "example": "If pointer_hit=0.8 and type_acc=0.7, then joint_acc <= 0.7",
      "gap_analysis": "Large gap between joint_acc and min(components) indicates independent errors"
    },
    "task_contribution_patterns": {
      "healthy": {
        "both_correct": ">0.50",
        "both_wrong": "<0.20",
        "description": "Model performs well on both tasks simultaneously"
      },
      "pointer_bottleneck": {
        "type_only_correct": ">0.30",
        "pointer_only_correct": "<0.10",
        "recommendation": "Increase loss_beta or improve pointer architecture"
      },
      "type_bottleneck": {
        "pointer_only_correct": ">0.30",
        "type_only_correct": "<0.10",
        "recommendation": "Decrease loss_beta or improve type classifier"
      },
      "high_both_wrong": {
        "both_wrong": ">0.40",
        "recommendation": "Model capacity issue - consider larger architecture or better pre-training"
      }
    }
  },

  "cli_integration": {
    "automatic_display": "Joint metrics computed automatically when --predict-pointers is enabled",
    "output_location": "Displayed after pointer regression metrics, before MC Dropout",
    "warnings": {
      "joint_accuracy_low": {
        "threshold": 0.30,
        "message": "Joint accuracy < 30% - tasks may be competing!"
      }
    }
  },

  "implementation_notes": {
    "tolerance": "Default Â±3 bars for pointer hit (configurable)",
    "type_labels": "Binary classification (0 or 1)",
    "pointer_hit_definition": "BOTH start AND end within tolerance",
    "averaging": "F1 uses weighted averaging by default (handles class imbalance)"
  }
}
